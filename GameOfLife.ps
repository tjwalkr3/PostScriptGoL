%!PS

/pageSize 10 def                          % Number of cells along each side
/cellSize 15 def                          % Size of each cell in points (pixels)
/iterations 100 def                       % Number of iterations to run Conway's Game of Life
/totalPageSize pageSize cellSize mul def  % Total page size in points
/random false def     % true: init with random, false: init with glider

<< /PageSize [totalPageSize totalPageSize] >> setpagedevice  % Set the actual page size in points

/swap2 { % a b c d -- c d a b prints as b a d c with pstack
    4 2 roll
} def

/drawline { % fromx fromy tox toy --
    swap2
    moveto
    lineto
    stroke
} def

% Draw horizontal line at a given y position (scaled by cellSize)
/hline { % y (in terms of cell index) --
    /y exch def
    0 y cellSize mul totalPageSize y cellSize mul drawline
} def

% Draw vertical line at a given x position (scaled by cellSize)
/vline { % x (in terms of cell index) --
    /x exch def
    x cellSize mul 0 x cellSize mul totalPageSize drawline
} def

% Procedure to draw the grid
/drawGrid {
    % Set the fill color to black, otherwise it will be the last used color
    0 0 0 setrgbcolor

    % Draw the vertical lines for the grid
    0 1 pageSize {
        dup vline         % Draw vertical line at x
    } for

    % Draw the horizontal lines for the grid
    0 1 pageSize {
        dup hline         % Draw horizontal line at y
    } for
} def

% Procedure to fill in cells based on a 2D array of ones and zeros
/fillCells { % gridArray (the array of cells), pageSize (side length) -- 
    /gridArray exch def

    0 1 pageSize 1 sub {  % Iterate over rows (y-axis)
        /row exch def
        0 1 pageSize 1 sub {  % Iterate over columns (x-axis)
            /col exch def
            /currentCell gridArray row get col get def
            currentCell 1 eq {
                col cellSize mul totalPageSize row 1 add cellSize mul sub moveto % move to the bottom left corner of a cell
                cellSize 0 rlineto          % Draw right (to the bottom-right corner)
                0 cellSize rlineto          % Draw up (to the top-right corner)
                cellSize -1 mul 0 rlineto   % Draw left (to the top-left corner)
                closepath                   % Close the path (back to starting point)
                0.1451 0.6563 0.2969 setrgbcolor       % Set the fill color to black
                fill                                   % Fill the square with the current color
            } if
        } for
    } for
} def

/wrapUp {
    % Take index from the stack
    /index exch def

    % Check if index equals count
    index pageSize 1 sub eq { 
        0 
    } { 
        index 1 add 
    } ifelse
} def

/wrapDown {
    % Take index from the stack
    /index exch def

    % Check if index equals 1
    index 0 eq {
        pageSize 1 sub
    } {
        index 1 sub
    } ifelse
} def

/countNeighbors {
    /col exch def
    /row exch def
    /counter 0 def

    % right
    sampleGrid row get col wrapUp get 1 eq { 
        /counter counter 1 add def 
    } if

    % left
    sampleGrid row get col wrapDown get 1 eq { 
        /counter counter 1 add def 
    } if

    % up
    sampleGrid row wrapDown get col get 1 eq { 
        /counter counter 1 add def 
    } if

    % down
    sampleGrid row wrapUp get col get 1 eq { 
        /counter counter 1 add def 
    } if

    % up right
    sampleGrid row wrapDown get col wrapUp get 1 eq { 
        /counter counter 1 add def 
    } if

    % up left
    sampleGrid row wrapDown get col wrapDown get 1 eq { 
        /counter counter 1 add def 
    } if

    % down right
    sampleGrid row wrapUp get col wrapUp get 1 eq { 
        /counter counter 1 add def 
    } if

    % down left
    sampleGrid row wrapUp get col wrapDown get 1 eq { 
        /counter counter 1 add def 
    } if

    counter
} def

/liveOrDie {
    /currentCell exch def
    /neighborCount exch def

    neighborCount 1 gt neighborCount 4 lt and {
        neighborCount 2 eq currentCell 0 eq and {
            false
        } {
            true
        } ifelse
    } {
        false
    } ifelse
} def

/gameOfLife {
    % Create a new empty board (2D array) to store the next state
    /newBoard [pageSize { [pageSize { 0 } repeat]} repeat] def

    % Iterate over each row (y-axis)
    0 1 pageSize 1 sub {
        /row exch def
        0 1 pageSize 1 sub {
            /col exch def
            /neighborCount row col countNeighbors def
            /currentCell sampleGrid row get col get def

            neighborCount currentCell liveOrDie {
                newBoard row get col 1 put  % If the cell should live, update the new board with a 1
            } {
                newBoard row get col 0 put  % If the cell should die, update the new board with a 0
            } ifelse
        } for
    } for

    % Update sampleGrid with the new board for the next iteration
    /sampleGrid newBoard def
} def

/sampleGrid [pageSize { [pageSize { 0 } repeat]} repeat] def

/initializeGlider {
    /sampleGrid [pageSize { [pageSize { 0 } repeat]} repeat] def
    sampleGrid 2 get 0 1 put
    sampleGrid 2 get 1 1 put
    sampleGrid 2 get 2 1 put
    sampleGrid 1 get 2 1 put
    sampleGrid 0 get 1 1 put
} def

/initializeRandom {
    /sampleGrid [pageSize { [pageSize { rand 2 mod } repeat]} repeat] def
} def

random {
    initializeRandom
} {
    initializeGlider
} ifelse

% Show the same page 10 times
iterations {
    drawGrid
    sampleGrid fillCells
    gameOfLife
    showpage
} repeat


%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beginning of Assert Code
%%%%%%%%%%%%%%%%%%%%%%%%%%

/each { % n proc -- executes proc for each i from 0 to n - 1
    0 1 swap2
    exch 1 sub
    exch
    for
} def

/arrayLengths { % a1 a2 -- l1 l2
    length
    exch length exch
} def

/top2AreArrays { % a1 a2 -- b
    type /arraytype eq
    exch type /arraytype eq
    and
} def

/indexEach { % a1 a2 k -- a1 a2 a1[k] a2[k]
    3 copy    
    % a1 a2 k a1 a2 k
    get
    % a1 a2 k a1 a2[k]
    3 1 roll
    % a1 a2 a2[k] k a1 
    exch get
    % a1 a2 a2[k] a1[k]
    exch
} def

/sameLengths { % a1 a2 -- b
    arrayLengths eq
} def

/saveStart { % a1 a2 -- true a1 a2
    true 3 1 roll
} def

/softEqual { % v1 v2 -- v1==v2
    2 copy top2AreArrays {
        arrayEqual
    } {
        eq
    } ifelse
} def

/andAndSave2Before { % b1 x y b2 -- b1&b2 x y
    4 -1 roll and
    % x y b
    3 1 roll
} def

/areAllEqual { % a1 a2 -- !!!
    saveStart
    dup length 
    {
        indexEach softEqual
        andAndSave2Before
    } each
    pop
    pop
} def

/arrayEqual { % a1 a2 -- b
    2 copy sameLengths {
        areAllEqual
    } {
        pop pop
        false
    } ifelse
} def

/assertEqual { % a b --
    2 copy softEqual not {
        exch
        (Assertion Failed!!\n) print
        (Expected: ) print ==
        (Was:      ) print ==
        quit
    } if
    pop pop
} def

/buildBoard {
    [pageSize { [pageSize { 0 } repeat]} repeat]
} def

%%%%%%%%%%%%%%%%%%%%
% End of Assert Code
%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%
% Beginning of Tests
%%%%%%%%%%%%%%%%%%%%

% Test the wrapping functions in the context of array indexing
0 9 wrapUp assertEqual
9 8 wrapUp assertEqual
9 0 wrapDown assertEqual
8 9 wrapDown assertEqual

/sampleGrid [
    [3 5 0 1 6]
    [1 1 1 0 2]
    [4 7 0 1 8]
    [1 0 1 0 1]
    [0 1 0 1 0]
] def

/col 0 def
/row 1 def
/pageSize 5 def

% right
1 sampleGrid row get col wrapUp get assertEqual
% left
2 sampleGrid row get col wrapDown get assertEqual
% up
3 sampleGrid row wrapDown get col get assertEqual
% down
4 sampleGrid row wrapUp get col get assertEqual
% up right
5 sampleGrid row wrapDown get col wrapUp get assertEqual
% up left
6 sampleGrid row wrapDown get col wrapDown get assertEqual
% down right
7 sampleGrid row wrapUp get col wrapUp get assertEqual
% down left
8 sampleGrid row wrapUp get col wrapDown get assertEqual

% Test the neighbor count functions on a larger array
/sampleGrid [
    [0 0 0 0 0 0 0 0 0 0]
    [0 0 1 0 0 0 0 0 0 0]
    [0 0 0 1 0 0 0 0 0 0]
    [0 1 1 1 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0]
    [0 1 0 0 0 0 0 0 0 1]
    [0 1 0 0 0 0 0 0 0 1]
    [0 1 0 0 0 0 0 0 0 1]
    [0 0 0 0 0 0 0 0 0 0]
] def

/pageSize 10 def

5 2 2 countNeighbors assertEqual
6 7 0 countNeighbors assertEqual
4 6 0 countNeighbors assertEqual

% test liveOrDie
