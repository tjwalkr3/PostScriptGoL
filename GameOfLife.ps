%!PS
% watch -n 3 ps2pdf GameOfLife.ps GameOfLife.pdf
% PDF Viewer by Mathematic Inc

/pageSize 10 def                          % Number of cells along each side
/cellSize 15 def                          % Size of each cell in points (pixels)
/iterations 5 def                        % Number of iterations to run Conway's Game of Life
/totalPageSize pageSize cellSize mul def  % Total page size in points

<< /PageSize [totalPageSize totalPageSize] >> setpagedevice  % Set the actual page size in points

/assertEqual { % a b --
    2 copy softEqual not {
        exch
        (Assertion Failed!!\n) print
        (Expected: ) print ==
        (Was:      ) print ==
        quit
    } if
    pop pop
} def

/buildBoard {
    [pageSize { [pageSize { 0 } repeat]} repeat]
} def

/swap2 { % a b c d -- c d a b prints as b a d c with pstack
    4 2 roll
} def

/drawline { % fromx fromy tox toy --
    swap2
    moveto
    lineto
    stroke
} def

% Draw horizontal line at a given y position (scaled by cellSize)
/hline { % y (in terms of cell index) --
    /y exch def
    0 y cellSize mul totalPageSize y cellSize mul drawline
} def

% Draw vertical line at a given x position (scaled by cellSize)
/vline { % x (in terms of cell index) --
    /x exch def
    x cellSize mul 0 x cellSize mul totalPageSize drawline
} def

% Procedure to draw the grid
/drawGrid {
    % Set the fill color to black, otherwise it will be the last used color
    0 0 0 setrgbcolor

    % Draw the vertical lines for the grid
    0 1 pageSize {
        dup vline         % Draw vertical line at x
    } for

    % Draw the horizontal lines for the grid
    0 1 pageSize {
        dup hline         % Draw horizontal line at y
    } for
} def

% Procedure to fill in cells based on a 2D array of ones and zeros
/fillCells { % gridArray (the array of cells), pageSize (side length) -- 
    /gridArray exch def

    0 1 pageSize 1 sub {  % Iterate over rows (y-axis)
        /row exch def
        0 1 pageSize 1 sub {  % Iterate over columns (x-axis)
            /col exch def
            /currentCell gridArray row get col get def
            currentCell 1 eq {
                col cellSize mul totalPageSize row 1 add cellSize mul sub moveto % move to the bottom left corner of a cell
                cellSize 0 rlineto          % Draw right (to the bottom-right corner)
                0 cellSize rlineto          % Draw up (to the top-right corner)
                cellSize -1 mul 0 rlineto   % Draw left (to the top-left corner)
                closepath                   % Close the path (back to starting point)
                0.1451 0.6563 0.2969 setrgbcolor       % Set the fill color to black
                fill                                   % Fill the square with the current color
            } if
        } for
    } for
} def

/wrapUp {
    % Take index from the stack
    /index exch def

    % Check if index equals count
    index count 1 sub eq { 
        0 
    } { 
        index 1 add 
    } ifelse
} def

/wrapDown {
    % Take index from the stack
    /index exch def

    % Check if index equals 1
    index 0 eq {
        pageSize 1 sub
    } {
        index 1 sub
    } ifelse
} def

/countNeighbors {
    /row exch def
    /col exch def
    /counter 0 def

    % right
    /neighbor1 gridArray row get col wrapUp get def
    neighbor1 1 eq { counter 1 add } if
    % left
    /neighbor2 gridArray row get col wrapDown def
    neighbor2 1 eq { counter 1 add } if
    % up
    /neighbor3 gridArray row wrapUp get col get def
    neighbor3 1 eq { counter 1 add } if
    % down
    /neighbor4 gridArray row wrapDown get col get def
    neighbor4 1 eq { counter 1 add } if
    % up right
    /neighbor5 gridArray row wrapUp get col wrapUp get def
    neighbor5 1 eq { counter 1 add } if
    % up left
    /neighbor6 gridArray row wrapUp get col wrapDown get def
    neighbor6 1 eq { counter 1 add } if
    % down right
    /neighbor7 gridArray row wrapDown get col wrapUp get def
    neighbor7 1 eq { counter 1 add } if
    % down left
    /neighbor8 gridArray row wrapDown get col wrapDown get def
    neighbor8 1 eq { counter 1 add } if

    counter
} def

/countAllNeighbors { % gridArray (the array of cells), pageSize (side length) -- 
    /gridArray exch def

    0 1 pageSize 1 sub {  % Iterate over rows (y-axis)
        /row exch def
        0 1 pageSize 1 sub {  % Iterate over columns (x-axis)
            /col exch def
            row col countNeighbors =
        } for
    } for
} def

% Example 2D array of ones and zeros (5x5 grid)
/sampleGrid [
    [0 0 0 0 0 0 0 0 0 0]
    [0 0 1 0 0 0 0 0 0 0]
    [0 0 0 1 0 0 0 0 0 0]
    [0 1 1 1 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0]
] def

/drawpage {
    drawGrid
    sampleGrid fillCells
    showpage
} def

% Show the same page 10 times
iterations {
    drawpage
} repeat